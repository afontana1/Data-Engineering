# Standard library imports
import os
import zipfile
import logging
import re
import datetime

# Local imports
from src.api_model import EragAPI
from src.look_and_feel import error, success, warning, info
from src.settings import settings

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

class CodeEditor:
    def __init__(self, worker_erag_api: EragAPI, supervisor_erag_api: EragAPI, manager_erag_api: EragAPI = None):
        self.worker_api = worker_erag_api
        self.supervisor_api = supervisor_erag_api
        self.manager_api = manager_erag_api
        self.files = {}
        self.output_folder = None
        self.allowed_file_types = {
            'py': 'Python',
            'js': 'JavaScript',
            'html': 'HTML',
            'css': 'CSS',
            'json': 'JSON',
            'md': 'Markdown'
        }
        print(info(f"CodeEditor initialized with worker API: {self.worker_api.api_type}, supervisor API: {self.supervisor_api.api_type}"))
        if self.manager_api:
            print(info(f"Manager API: {self.manager_api.api_type}"))

    def clean_api_response(self, response, file_type):
        logging.debug(f"Cleaning API response for file type: {file_type}")
        logging.debug(f"Original response: {response}")
        
        # Remove any text before and after the code block
        code_block_pattern = r'```[\w\s]*\n([\s\S]*?)\n```'
        code_blocks = re.findall(code_block_pattern, response)
        
        if code_blocks:
            # If code blocks are found, use the last one (in case there are multiple)
            cleaned_code = code_blocks[-1].strip()
        else:
            # If no code blocks are found, use the entire response
            cleaned_code = response.strip()
        
        # Remove any remaining markdown code block syntax
        cleaned_code = cleaned_code.replace('```' + file_type, '').replace('```', '')
        
        # Remove any "Here is the improved/polished version of the code:" or similar phrases
        cleaned_code = re.sub(r'^.*?(Here is|This is|Updated|Improved|Polished).*?\n', '', cleaned_code, flags=re.IGNORECASE | re.MULTILINE)
        
        cleaned_code = cleaned_code.strip()
        logging.debug(f"Cleaned response: {cleaned_code}")
        return cleaned_code

    def sanitize_filename(self, filename: str) -> str:
        # Remove any path components (e.g., 'foo/bar')
        filename = os.path.basename(filename)
        # Remove any non-alphanumeric characters except for periods, hyphens, and underscores
        filename = re.sub(r'[^\w\-_\.]', '', filename)
        # Ensure the filename is not too long (max 255 characters)
        filename = filename[:255]
        return filename

    
    def save_file(self, filename, content):
        if self.output_folder is None:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            self.output_folder = os.path.join(settings.output_folder, f"generated_app_{timestamp}")
            os.makedirs(self.output_folder, exist_ok=True)
            logging.info(f"Created output folder: {self.output_folder}")

        safe_filename = self.sanitize_filename(filename)
        file_path = os.path.join(self.output_folder, safe_filename)
        logging.debug(f"Saving file: {file_path}")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            logging.info(f"Saved file: {file_path}")
        except IOError as e:
            logging.error(f"Error saving file: {str(e)}")


    def generate_application(self, request):
        print(info("Generating application..."))
        try:
            # Step 1: Worker generates initial file structure and content
            self.worker_generate_initial(request)

            if not self.files:
                raise Exception("No files were generated by the worker.")

            # Step 2: Supervisor improves the files
            self.supervisor_improve(request)

            # Step 3: Manager further improves the files (if available)
            if self.manager_api:
                self.manager_improve(request)

            # Create zip
            self.create_zip()

            print(success(f"Application generated and improved successfully!\nFiles saved in: {self.output_folder}"))
        except Exception as e:
            error_message = f"An error occurred while generating the application: {str(e)}"
            logging.error(error_message)
            print(error(error_message))
            import traceback
            logging.error(traceback.format_exc())

    def worker_generate_initial(self, request):
        logging.info("Worker: Generating initial file structure and content...")
        file_structure_prompt = f"""Create a basic application structure based on this request: {request}
        Provide a list of files needed for this application, each on a new line. 
        Include only the file names with appropriate extensions. 
        Use standard naming conventions (e.g., snake_case for Python, camelCase for JavaScript).
        Allowed file types are: {', '.join(self.allowed_file_types.keys())}"""
        
        file_list_response = self.worker_api.chat([{"role": "user", "content": file_structure_prompt}])
        logging.debug(f"File list response: {file_list_response}")
        file_list = [file.strip() for file in file_list_response.split('\n') if file.strip() and '.' in file]
        file_list = [file for file in file_list if file.split('.')[-1] in self.allowed_file_types]
        logging.info(f"Files to be created: {file_list}")

        if not file_list:
            logging.warning("No valid files were listed by the worker.")
            return

        for file in file_list:
            file_type = self.allowed_file_types.get(file.split('.')[-1], "Unknown")
            content_prompt = f"""Generate the initial content for the file '{file}' ({file_type}) for the application: {request}
            Ensure the code is complete, syntactically correct, and follows best practices for {file_type}.
            Provide only the code, no explanations."""
            content = self.worker_api.chat([{"role": "user", "content": content_prompt}])
            logging.debug(f"Raw content for {file}: {content}")
            cleaned_content = self.clean_api_response(content, file_type)
            logging.debug(f"Cleaned content for {file}: {cleaned_content}")
            self.files[file] = cleaned_content
            self.save_file(file, cleaned_content)

        logging.info(f"Worker generated {len(self.files)} files.")

    def supervisor_improve(self, request):
        logging.info("Supervisor: Improving files...")
        for file, file_content in self.files.items():
            file_type = self.allowed_file_types.get(file.split('.')[-1], "Unknown")
            improve_prompt = f"""Improve the following {file_type} code for the file '{file}' in the application: {request}

Current content:
{file_content}

Please provide an improved version of this code. Focus on:
1. Enhancing functionality and features
2. Improving code structure and organization
3. Implementing best practices and design patterns
4. Optimizing performance
5. Enhancing error handling and security

IMPORTANT: 
- Ensure that your improvements do not break existing functionality or reduce the quality of the code.
- If you cannot meaningfully improve the code without risking its functionality, return the original code unchanged.
- Provide ONLY the improved code, without any explanations or markdown formatting.
"""

            improved_file_content = self.supervisor_api.chat([{"role": "user", "content": improve_prompt}])
            cleaned_content = self.clean_api_response(improved_file_content, file_type)
            self.files[file] = cleaned_content
            self.save_file(file, cleaned_content)

        logging.info(f"Supervisor improved {len(self.files)} files.")
    
    def manager_improve(self, request):
        logging.info("Manager: Further improving the application...")
        for file, file_content in self.files.items():
            file_type = self.allowed_file_types.get(file.split('.')[-1], "Unknown")
            improve_prompt = f"""Further improve the following {file_type} code for the file '{file}' in the application: {request}

Current content:
{file_content}

Please provide a final, polished version of this code. Focus on:
1. Ensuring all features are fully implemented
2. Optimizing code efficiency and performance
3. Enhancing code readability and maintainability
4. Implementing advanced error handling and logging
5. Ensuring security best practices are followed
6. Adding helpful comments and documentation

IMPORTANT: 
- Ensure that your improvements do not break existing functionality or reduce the quality of the code.
- If you cannot meaningfully improve the code without risking its functionality, return the original code unchanged.
- Provide ONLY the improved code, without any explanations or markdown formatting.
"""

            final_file_content = self.manager_api.chat([{"role": "user", "content": improve_prompt}])
            cleaned_content = self.clean_api_response(final_file_content, file_type)
            self.files[file] = cleaned_content
            self.save_file(file, cleaned_content)
    
    def create_zip(self):
        if not self.files:
            print(warning("No files to zip. Application generation might have failed."))
            return

        if self.output_folder:
            zip_path = os.path.join(self.output_folder, "generated_app.zip")
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for filename, content in self.files.items():
                    zipf.writestr(filename, content)
            print(success(f"ZIP file created: {zip_path}"))
        else:
            print(warning("No output folder found. ZIP file could not be created."))

    def run(self):
        print(info("Welcome to the AI-powered Application Generator"))
        request = input("Enter your application request: ")
        self.generate_application(request)
